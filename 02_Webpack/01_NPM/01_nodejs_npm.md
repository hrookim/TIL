# NPM

> Node.js 기술이 우대사항으로 FE 채용에 추가되었다. 이는 개발환경을 이해하고 설정하는 데에 적지 않은 역할을 한다. 그래서 FE 개발에 Node.js 개발이 필요하다



## 프론트엔드 개발에 Node.js가 필요한 이유

### 1. 최신 스펙으로 개발할 수 있다.

* JS는 빠르게 발전하고 있는 한편, 브라우저의 지원 속도는 뒤쳐진다.
* 아무리 편리한 스펙이 나오더라도 브라우저에 맞게 변환해주는 기술(바벨, 웹팩)이 필요하다.
* 그리고 이 기술들은 Node.js 위에서 돌아가는 기술들이다.
* TS, SASS를 사용하려면 전용 트랜스파일러가 필요한데, 이것도 Node.js가 뒷받침되어야 한다.



### 2. 빌드 자동화

* 파일을 압축하고, 코드를 난독화하는 등 개발 이외의 후속작업을 한 후 배포한다.
* Node.js는 이 빌드 과정을 이해하는 데에 필요하다
* 프로젝트에 필요한 라이브러리를 다운받고, 각종 테스트를 자동화하는 데 사용된다.



### 3. 개발 환경 커스터마이징

* 개발 프로젝트는 각자의 형편이 있어서 자동화 툴(React, Vue-cli)를 바로 사용할 수 없을 수 있다.
* 커스텀이 필요하기 때문에, 직접 개발환경을 구축해야하기 때문에 필요하다.



## Node.js 설치

* 설치를 완료하면, `Node.js`와 `npm`이 설치된다.
* `Node.js`를 실행하면, `>` 프롬프트와 함께 입력 대기 화면이 나온다. 
  * 이것을 REPL(read-eval-print loop)이라고 부르는데, JS 코드를 입력하고 즉시 결과를 확인할 수 있다. 



## 프로젝트 초기화

* 개발 프로젝트는 외부 라이브러리를 다운로드 받고 빌드하는 등 일련의 명령어를 자동화하여 프로젝트를 관리하는 도구가 존재
  * ex) PHP의 composet, Java의 gradle 등..
  * npm은 JS기반 프로젝트의 빌드 도구인 셈



### Init

```bash
$ npm init
// 프로젝트를 생성하고, 관련 메타 데이터를 입력할 수 있다.
```

* 메타 데이터를 다 입력하고 프로젝트를 생성하면 -> `package.json`이 생성된다.
* 그 안의 데이터는 다음과 같이 작성되어 있다.

```json
{
  "name": "sample",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "",
  "license": "ISC"
}

```

> main: node.js에서 사용되는 것
>
> scripts: 프로젝트를 자동화할 수 있는 shell script를 입력하는 부분 (프로젝트 명령어)



### 프로젝트 명령어

* `package.json`의 `scripts`에 입력되어 있는 명령어를 실행하려면 `npm` + `명령어`를 입력하면 된다.

* 기본으로 제공되는 command 외에 command를 추가하고 싶다면, `scripts`에 추가하면 된다.

  * 커스텀 command를 실행하고 싶다면 아래의 명령어를 입력하면 된다.

  * ```bash
    $ npm run {command}
    ```



## 외부 패키지를 관리하는 방법

### 1. CDN을 이용하는 방법

* CDN(Contents Delivery Network): JS 라이브러리 혹은 CSS 라이브러리를 빠르게 제공해주는 서버
  * CDN 서버 장애가 난다면 외부 라이브러리를 가져올 수 없다. 
  * 그러므로, 장애와 무관하게 사용을 하려면 다른 방법을 사용해야 한다.



### 2. 직접 다운로드하는 방법

* 라이브러리 코드를 우리 프로젝트에 직접 다운받아 놓는다면 서버 장애와 독립적으로 제공할 수 있다.
* 그러나, 라이브러리는 계속해서 업데이트되므로 우리 프로젝트도 최신 버전으로 교체할 필요가 있다.
  * 이것을 수작업으로 한다면 human error가 발생하기 쉽다.



### 3. npm을 사용하는 방법

* 이를 방지하기 위한 방법이 npm으로 의존성을 관리하는 방법이다.

* `npm i`를 이용하면, 우리 프로젝트에 라이브러리를 설치할 수 있다.

  * `npm i react`를 하고 나면, `package.json`에 다음과 같은 변화가 생긴다.

  * ```json
    {
      "name": "sample",
      "version": "1.0.0",
      "description": "",
      "main": "index.js",
      "scripts": {
        "test": "echo \"Error: no test specified\" && exit 1",
        "build": "echo \"여기에 빌드 스크립트를 추가합니다\""
      },
      "author": "",
      "license": "ISC",
      "dependencies": {
        "react": "^18.2.0"
      }
    }
    
    ```

    > dependencies에 react가 추가된 것을 확인할 수 있다!



#### 유의적 버전(semantic version)과 버전의 범위

> "react": **"^18.2.0"**은 무엇을 의미할까?



* 프로젝트에서 사용하는 버전을 엄격하게 관리한다면, 버전업을 하는 것이 어려울 수 있다.
* 반대로 너무 느슨하게 한다면, 여러 버전을 코드로 관리해야 하기 때문에 혼란을 겪을 수 있다.
* 그래서 버전을 관리할 수 있는 법칙이 필요하다. -> npm은 **semantic version**을 따르고 있다!



* **Semantic version**: `주.부.수`
  * 주 버전(major): 기존 버전과 호환되지 않게 변경한 경우
  * 부 버전(minor): 기존 버전과 호환되면서 기능이 추가된 경우
  * 수 버전(patch): 기존 버전과 호환되면서 버그를 수정한 경우



* **버전의 범위**
  1. 버전을 그대로 명시하는 것 -> 해당 버전만 설치
  2. 부등호 -> 부등호에 맞는 버전만 설치
  3. 틸트(`~`)와 캐럿(`^`)을 사용한 경우
     * 틸트: 마이너 버전이 명시되어 있으면 패치 버전을 변경하고, 마이너 버전이 명시되어 있지 않으면 마이너 버전을 갱신한다.
     * 캐럿: 정식버전에서 마이너와 패치버전을 변경한다. 정식버전 미만(0.x버전)에서는 패치만 갱신한다.
* 과거에는 틸트를 이용했으나, 요즘에는 캐럿을 사용하여 버전을 나타낸다.
  * why?
  * 보통 라이브러리 정식 릴리즈 전에는 패키지 버전이 수시로 변한다. 그니까 0.1 -> 0.2임에도 불구하고 하위 호환성을 지키지 못한 경우가 빈번하다는 것이다. 이럴 때 `~0`을 사용한다면 하위 호환성을 지키지 못하는 버전으로 업데이트 되어버리는 문제가 생길 수 있다.
  * `^0.0`을 사용한다면, 패치버전만 갱신되므로 하위 호환성을 유지할 수 있다.

